// 35: Symbol.for - retrieves or creates a runtime-wide symbol
// To do: make all tests pass, leave the assert lines unchanged!
// Follow the hints of the failure messages!

describe('`Symbol.for` for registering Symbols globally', function() {
  it('creates a new symbol (check via `typeof`)', function() {
    const symbolType = typeof Symbol.for('symbol');
    assert.equal(symbolType, 'symbol');
  });
  it('stores the symbol in a runtime-wide registry and retrieves it from there', function() {
    const sym = Symbol.for('new symbol'); 
    const sym1 = Symbol.for('new symbol');// removed the 1 at the end of the string to make them equal
    assert.equal(sym, sym1);
  });
  it('is different to `Symbol()` which creates a symbol every time and does not store it', function() {
    var globalSymbol = Symbol('new symbol');// got rid of symbol.for to make each unique 
    var localSymbol = Symbol('new symbol');
    assert.notEqual(globalSymbol, localSymbol);
  });
  describe('`.toString()` on a Symbol', function() {
    it('also contains the key given to `Symbol.for()`', function() {
      const description = Symbol('new symbol').toString();// added new symbol inside string 
      assert.equal(description, 'Symbol(new symbol)');// to make them equal since .string
    });
    describe('NOTE: the description of two different symbols', function() {
      it('might be the same', function() {
        const symbol1AsString = Symbol.for('new symbol 1').toString();
        const symbol2AsString = Symbol.for('new symbol 1').toString();
        assert.equal(symbol1AsString, symbol2AsString);
      });
      it('but the symbols are not the same!', function() {
        const symbol1 = Symbol('new symbol');// removed .for to have the symbols not equal
        const symbol2 = Symbol('new symbol');
        assert.notEqual(symbol1, symbol2);
      });
    });    
  });
});
